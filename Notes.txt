So we can't use a command, as an ICommand type is intended for only a single recipient, which is enforced by NServiceBus.

Could use pub/sub--but how would we know how many we're waiting to receive back?  Maybe we don't care, we wait for either an expected number or a timeout.  What if we don't know how many to expect?  Or what if the number to expect a response from varies?  

We could conceivably have an immediate response on the RequestBankQuote, with the LoanBroker keeping track for a given request how many responses we expect (basing the number on the subscribers that seem to be online and working on a response).  You'd still have a timeout, but that would avoid excessive delays in situations where a bank was offline.

Change to pub/sub model for RequestBankQuote?  That sounds like mixing a command (request a bank qutoe) with an event (want to send a message to multiple receivers).  Problem is that a command is, by design, intended for a single receiver.  A publisher is not intended to be aware of subscribers, if any.  This one gets weird b/c we kind of want to publish an event, but we expect a certain number of responders.  How many?  Probably can estimate by getting an initial response back (i.e. reply to the original event and increment an expected counter).  Then how do we aggregate the responses?  Possibly can use a saga here.

Saga keeps track of response state, with a timeout in case an expected bank doesn't respond.  How will this work?

RequestBankQuote starts the saga with BankQuoteRequestId.  Sends off messages to banks.  When all responses are received, completes the saga, which sends a BankQuoteComplete message with the quotes.  So how does it know which banks to send to?  


Still need to figure out the request/reply pattern.  See https://docs.particular.net/nservicebus/sagas/reply-replytooriginator-differences
https://docs.particular.net/tutorials/nservicebus-sagas/3-integration/

Good notes here on dealing with external web service calls and sagas: https://docs.particular.net/tutorials/nservicebus-sagas/3-integration/

BankQuotesService.Messages
	

BankQuoteService.Messages
	RequestBankQuotes : ICommand
		RequestId - ID for the initial request for bank quotes.
		
		Ssn
		CreditScore
		HistoryLength
		LoanAmount
		LoanTerm

	BankQuotesComplete : IMessage
		RequestId
		
		BankQuotes[]
			BankQuoteId
			
			ErrorCode
			BankAssignedId
			InterestRate

	Internal data structures:
	
	BankQuoteTimeout
		RequestId



ExternalBankService.Messages
	ExternalBankQuoteRequest : ICommand
		RequestId - ID from request bank quotes
		BankQuoteId - ID for the individual bank quote
		
		Ssn
		CreditScore
		HistoryLength
		LoanAmount
		LoanTerm
		
	ExternalBankQuoteReply : IMessage
		RequestId
		BankQuoteId
		
		ErrorCode
		BankAssignedId
		InterestRate
		
		

Saga
GatherBankQuotes
	started by: RequestBankQuotes
	handles messages: IndividualBankQuoteReply
	on complete: sends BankQuotesComplete message
	Timeout: 15s, BankQuotesTimeout
	
	Saga data:
		GatherBankQuotesData
			RequestId
			BankQuotes[]
				BankId
				RequestSent
				RequestReceived
				
	
	
	Correlation ID: RequestId
	
	Handle(StartBankQuote)
		Generates and sends off RequestBankQuote commands to different bank services.
		Hard-coded list, for now, will move to dynamically generated list in the future, where we know how many replies to expect.
		
	Handle(BankQuoteReply)
		Updates structure tracking the bank quote replies.
		
		CheckComplete()
		
	CheckComplete()
		Checks whether all quotes have been received, if so, marks saga complete.
		Sends out message ???
		
	Timeout()
		Takes whatever bank quotes have been received, marks any unreceived bank quotes
		If no bank quotes received, "BankQuoteComplete" message with no completed banks (caller handles)
		Sends out message ???
		Mark complete
		
These individual banks...should I start up the individual services within the same endpoint?  No...should be separate.  Right now I'm combining the saga with the bank quote services.  That doesn't seem right.

Feels like I need a BankQuotesService and an ExternalBankService

BankQuotesService is for the saga.  ExternalBankService is an instance of a bank quote service.



Next steps: Send BankQuotesComplete response to the originator of the saga start message.  Should also implement a SagaNotFoundHandler for BankQuotesService so we can log some sort of notification of delayed bank quote responses.  After that, look at the CreditBureauService, where we'll decorate the requests with credit scores.  Need to also revisit the EIP book patterns we're supposed to be using.

Some future interesting things might be to implement on SqlExpress, and to roll out the different services into containers.

An interesting thing to note: external bank service appears to be single-threaded--only deals with a single message at a time.  We have capacity to fire off multiple messages.  Is it synchronous?

Moving on to CreditBureauService


Revisiting correlation ID.  Right now it's not clear which ID is used to correlate messages between which points.

NSB assigns MessageId to each message, stored in the header.  This is unique to each message generated by an endpoint.  https://docs.particular.net/nservicebus/messaging/message-identity

NSB has a CorrelationId field on message headers: https://docs.particular.net/nservicebus/messaging/headers#messaging-interaction-headers-nservicebus-correlationid

Message correlation connects request message with their corresponding response messages.  The 'CorrelationId' of the response message is the 'CorrelationId' of its corresponding request message.  Each outgoing message which is sent outside of a message handler will have its 'Correlation Id' set to its 'Message Id'.  Messages sent from a saga using the 'ReplyToOriginator' method will have their 'Correlation Id' set based on the message which caused the saga to be created.  

NSB has a 'ConversationId' field that allows tracking of message flows that span more than one message exchange.  First message sent in a new flow (what is a flow?) is auto assigned a unique 'ConversationId' that is propagated to all messages that are sent afterward, formaing a conversation.  Each message sent with a conversation has a 'RelatedTo' value that IDs the message that caused it to be sent.  

In certain scenarios, the 'ConversationId' must be assigned manually in cases where NSB can't infer when messages belong to the same conversation.  For example, when a 'CancelOrder' messge needs to be part of an existing order conversation, then the 'OrderID' can be used as the 'ConversationID'

'ConversationId' is very similar to 'CorrelationId'.  Both headers are copied to each new message that an endpoint produces.  Whereas 'ConversationId' is always copied from the incoming message being handled, 'CorrelationId' can come from another source (such as when replying from a saga using 'ReplyToOriginator()')

'RelatedTo' indicates 'MessageId' that caused the current message to be sent.  Whenever a message is sent or published from inside a message handler, its 'RelatedTo' header is set to the 'MessageId' of the incoming message that was being handled.  

For a single req/resp interaction 'CorrelationId' and 'RelatedTo' are very similar (i.e. 'CorrelationId' and 'RelatedTo' are both set in the response based on the message that triggered the response--the request).  Once a conversation is longer than a single req/response, 'CorrelationId' can be used to correlate a response to the original request.  'RelatedTo' can only correlate a message back to the previous message in the same conversation.  

What is the need w/ the correlation ID?  I need to know...which response belongs to which request.  Beyond that?  These things originate w/ a loan ID?

Referencing the book:

- p405: MQService.SendReply sets 'outMsg.CorrelationId = inMsg.Id', 'outMsg.AppSpecific = inMsg.AppSpecific'.  So I don't think we need to mess with correlation IDs in our code--they're handled automatically.  
- p419: Defining request message, assigns 'requestMessage.AppSpecific = random.Next()', defines a processor for handling the response, 'CreditRequestProcess', where 'processInstance.CorrelationId = requestMessage.AppSpecific', then saves off the 'processInstance' to a collection of active processes indexed on the correlation IDs, e.g. 'activeProcesses.Add(processInstance.CorrelationId, processInstance)'.  So we set the response to look for the 'AppSpecific' value from the original request.  We know when replies are sent the 'AppSpecific' is set on the reply according to what was passed in on the request.  

So how does all of this work with NSB?

- NSB 'CorrelationId' appears to be similar to what is defined in EIP--'CorrelationId' on response is set to 'MessageId' on the request.  
- EIP 'AppSpecific'?  I believe this is similar to 'ConversationId'?  Need to read more.

Idea with "AppSpecific": We don't want to correlate w/ message ID.  Message ID is unique for each message in the system.  If we require the reply message to correlate to the message ID of the request message, we cannot insert intermediate steps into the message flow.  Any intermediate step would consume the req message and publish a new message to the service, the reply message's correlation ID would match the service received.  So 'AppSpecific' is used to correlate messages that flow through intermediary

TODO: Sort out how IDs will be used across the various calls.  How do we keep things correlated?
